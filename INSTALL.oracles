-------------------------------------------------------------------------------
HOW TO CREATE A TLSNOTARY ORACLE EBS SNAPSHOT.
-------------------------------------------------------------------------------
In the Asia Pacific Singapore region create a volume from snap-3eb0e00a (this is the snapshot used by Ubuntu Server 14.04 LTS (PV), SSD Volume Type - ami-e8f1c1ba).
Attach the volume to any running instance as e.g. /dev/sdf.
Optionally, use "cp -pr" to copy all files from the 8GiB volume to a volume of a smaller size.

From within the instance:	
<bash>
  git clone https://github.com/tlsnotary/pagesigner-oracles
  cd pagesigner-oracles
  sudo -s
  mkdir /mnt/disk
  mount /dev/xvdf /mnt/disk
  DISK=/mnt/disk
  rm $DISK/etc/init.d/ssh
  rm $DISK/usr/sbin/sshd
  sed -i '136s/.*/ kernel          \/boot\/vmlinuz-3.13.0-48-generic root=\/dev\/xvda ro forcefsck console=hvc0/' $DISK/boot/grub/menu.lst
  sed -i 's/- bootcmd//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- runcmd//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- rightscale_userdata//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- scripts-user//' $DISK/etc/cloud/cloud.cfg
  touch $DISK/forcefsck
</bash>

For main server instance:
<bash>
	cp -R notary $DISK/root
	cp notary/rc.local $DISK/etc/rc.local
	chmod 755 $DISK/etc/rc.local && chown root:root $DISK/etc/rc.local
</bash>
	
For signing server instance:
<bash>
	cp -R signing_server $DISK/root
	cp signing_server/rc.local $DISK/etc/rc.local
	chmod 755 $DISK/etc/rc.local && chown root:root $DISK/etc/rc.local	
</bash>
	
	
"umount /dev/xvdf" and detach it in the AWS console.
Create a public snapshot from the volume and note the snapshot ID.

Create an AMI from the snapshot, making sure that:
Virtualization type is Paravirtual
Kernel ID is aki-503e7402
Root device name is /dev/xvda
Note the AMI ID and make the AMI public.


-------------------------------------------------------------------------------
HOW TO LAUNCH AN ORACLE INSTANCE FROM THE PUBLIC SNAPSHOT.
-------------------------------------------------------------------------------
The -b arguments are only used for the notary server, i.e. omit the -b arguments for the signing server.

ec2-run-instances 
	<id of the AMI you created>
	-t t1.micro
	-b /dev/xvdj=<id of the snapshot of the notary oracle for the previous version>::::
	-b /dev/xvdk=<id of the snapshot of the signing oracle for the previous version>::::
	-z ap-southeast-1a
	--region ap-southeast-1
	-O Access Key ID
	-W AWS Secret Access Key

Make sure that:
  Instance's "launchTime" and volume's "attachTime" happened on the same minute with no more than 5 seconds between the events.
  Volumes were created and attached on the same seconds.
  Console Output (right-click an instance ->Instance Settings -> Get System Log) is available, since it was observed that sometimes the instance doesn't have any.
  
After the main server AMI started, copy the main server pubkey from Console Log into pubkey.pem
Start the signing server with TCP port 10004 open and send it pubkey.pem: cat pubkey.pem | nc sigserverIP 10004
Make sure you hit the 20 sec window when the signing server is listening on that port, otherwise you'll get TCP RST.
Feed the sig server IP to the main server: echo -n '1.2.3.4' | nc mainserverIP 10011

After the notary server has started, you can detach volumes on /dev/xvdj and /dev/xvdk and delete them.


-------------------------------------------------------------------------------
HOW CAN YOU PROVE TO THE WORLD THAT A CERTAIN IP ADDRESS IS RUNNING THE ORACLE INSTANCE
-------------------------------------------------------------------------------

Use aws_query.py to create and publish URLs for requests 
DescribeInstances
DescribeInstanceAttribute
DescribeVolumes
GetUser
GetConsoleOutput


-------------------------------------------------------------------------------
FOR VERIFIERS: HOW TO CHECK THAT THE SNAPSHOT CONTENTS WAS NOT MALICIOUSLY MODIFIED.
-------------------------------------------------------------------------------


Repeat all the steps described in "HOW TO CREATE AN ORACLE EBS SNAPSHOT" but don't create a public snapshot.
Attach the resulting volume (volX) to a running instance as /dev/sdg
Create a volume from the snapshot (volY) you are verifying and attach it to /dev/sdh
After that, run from within the instance
<bash>
  sudo -s
  mkdir /mnt/disk1
  mkdir /mnt/disk2
  mount /dev/xvdg /mnt/disk1
  mount /dev/xvdh /mnt/disk2
</bash>
 
Compare the hashes of volX and volY. 
First hash file/directory/symlink paths, ownership, permissions, and symlink targets.
Then hash the contents of all regular files.
The outputs must match.
<bash>
  export LC_ALL=C 
  cd /mnt/disk1
  find . -printf '%h %f %U %G %m %l\n' | sort -t \n | sha256sum
  find . -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum

  cd /mnt/disk2
  find . -printf '%h %f %U %G %m %l\n' | sort -t \n | sha256sum
  find . -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum
</bash>


-------------------------------------------------------------------------------
FOR VERIFIERS: HOW TO DETERMINE THAT THE RUNNING ORACLE INSTANCE IS LEGIT
-------------------------------------------------------------------------------
The published URLs must pass the checks performed in functions starting with check* in content/oracles.js.


-------------------------------------------------------------------------------
POSSIBLE ATTACKS AND HOW THEY WILL BE MITIGATED
-------------------------------------------------------------------------------
(or in other words, what prevents the AWS account owner from modifying the oracle instance code)


Attack1.
Launch the AMI with a rogue snapshot on /dev/sda1
Mitigation:
AWS doesn't allow replacing the snapshotID on the root device.


Attack2.
Launch the AMI with a rogue snapshot on /dev/sda2 hoping that the AMI will boot it instead of /dev/sda1.
Mitgation:
When creating AMI, we changed the root device to /dev/xvda. We also changed a line in grub's menu.lst to pass root=/dev/xvda1 to kernel. Whereas before the kernel searched for a specific ext2label, now there is no wiggle room for the attacker.


Attack3.
Launch the AMI with /dev/sda1=none and a rogue snapshot on /dev/sda2. The AMI, in the absence of /dev/sda1, will boot /dev/sda2.
Attach the oracle snapshotID to /dev/sda1 and modify it. Then detach /dev/sda2 and reboot.
Upon reboot, /dev/sda1 will be chosen by the kernel as the root device.
Mitigation:
The attachment time of /dev/sda1 will differ from the time when AMI was started. This is a red flag.

Attack4.
Launch AMI with the user data passed in.
Mitigation:
DescribeInstanceAttribute API call will reveal that data was passed (in userData attribute). Since AWS doesn't allow to modify the user data while the instance is running, the data passed in at the start cannot be overwritten with blank data.
On top of that, we removed the bootcmd module from AMI's cloud-init. This module is responsible for handling the user Data.

Attack5.
The attacker can corrupt the filesystem's metadata in such a way as too exploit the kernel when it tries to mount the fs.
Mitigation:
We pass forcefsck from grub to kernel to check fs before mounting. (I havent research but I doubt that the fs checking utility runs with kernel privileges).